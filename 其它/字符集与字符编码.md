# 字符集与字符编码

本文参考[小孩子4919](https://juejin.im/post/5c847cb5f265da2dd63929c2#heading-17 )，此作者写的很好，我只是汲取其中的营养，然后用自己的语言描述出来，以及供以后复习使用。大家有兴趣的可以点进去读一读，会有很大的收获。

最近感觉程序猿这个职业简直太难了。到哪职业病都犯，总是能看到别人看不到的东西，常人无法理解了，别人都说我疯了，这不，前几天在网上看到了一个段子。说一个程序员去相亲网站相亲，结果没有找到女朋友，找到了相亲网站的Bug。。。

![16e67304449752c3](D:\表情包\16e67304449752c3.jpg)

## 字符介绍

什么是字符？

想必学习过编程语言的同学都知道字符这个概念，先举几个例子，例如a，b，和，e。他们如果组合起来，就形成了字符串，例如：我很帅，这个绝世名句就是由我，很，帅三个字符组成的，再说一遍，我、很、帅。

注意：字符都是单个的！

字符也是有分类的，字符分为可见字符、不可见字符

可见字符：可见字符就是平常我们眼睛可以看见的字符，也就是ASCII表中位于32~127位置的，他们是肉眼可见的，可以被打印出来的。
不可见字符：不可见字符也叫文本控制字符，就是为显示或者打印提供格式设定的字符，例如我们看不到的换行，制表，响铃等等。

![image_1bqi8qm43m71krg1gags7o1lhc9.png-455.4kB](https://user-gold-cdn.xitu.io/2019/3/10/169658713bfe706c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

带大家玩个好玩的，ASCII表中的10对应为响铃，当输出此符号时候，我们的可木piu特就会响铃一次。

还有就是换行的符号，在windows中，换行符号为/r/n(即此码表中的10和13)，而在linux中，换行符为/n(即此码表中的10)

## 字符集

什么是字符集？

字符集从字面理解就是字符的集合，但是，还需要加一点东西，字符集就是字符的集合以及字符对应的编码方式。

下面是字符、字符集、字符编码的比较：

- **字符(Character)**是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。
- **字符集(Character set)**是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。
- **字符编码**是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。编码方式一般就是对二维表的横纵坐标进行变换的算法。一般都比较简单，直接把横纵坐标拼一起就完事了。后来随着字符集的不断扩大，为了节省存储空间，才出现了各种各样的算法。

我们所说的字符集是字符的集合是在广义上的理解，真正在计算机层面的字符集就是编过码后的字符的集合。

不同字符集所收录的字符个数是不一样的，例如ASCII字符集收录了128个字符，而GB2312字符集收录了7445个字符，而且不同的字符集对应的字符编码方式是不一样的，是无法相互解码的，相信大家对烫烫烫这个段子应该很熟悉吧。

其实我们也可以建立我们的字符集以及对应的编码方式，只不过没人承认你这货，想想就放弃吧！一个字符集的诞生到计算机真正的使用需要经历以下5个步骤：

1. 明确包含字符的范围。 

   解释来说就是自定义的字符集包含了哪些字符，以及字符的编码顺序是什么样的，例如ASCII码，它的编码范围就是0-127，并且明确了包含哪些范围

2. 给步骤`1`中确定的字符进行编号。 

   确定了第一步，那么就是要对其中的每一个字符进行编号了。

   注意，编号和编码是有区别的，编号只不过是在逻辑层面上的，即没有涉及到计算机存储的，就是建立字符与数字的一一对应关系。但是编码是指序列化计算机中，存储二进制到计算机中的。

   举个例子，例如ASCII码中，A的编号为65，A的编码为01000001

3. 将步骤`2`中的`编号`确定`逻辑上的字符编码`。 

   此步骤就是对步骤2中的编号进行序列化处理了，序列为计算机能存储的二进制数据。

   此处就要引出码元的概念了，码元就是计算机一次读取编码的字节数，这个是由编码自身决定的，有的编码一个字节为码元，即单码元，有的编码两个字节为一个码元，称为多码元。

   为什么称之为逻辑编码呢，因为此步骤生成的编码并不是真正存储到计算机中的编码，这一步只不过是确定了码元大小以及二进制编码，并没有对此二进制编码进行排序，所以称之为码元序列。

   对于同一种字符集，可能也会存在不同的编码方式，在步骤2中，编号的方式或者算法的不同，或者码元大小不一样等都会产生不同的编码。例如Unicode和utf8、utf16、utf32，这就是明显的码元大小不相等。下面会详细介绍这些编码的。

4. 给步骤`3`中确定的逻辑上的字符编码生成物理上的字符编码。 

   经过上面的处理，生成了码元序列，这一步就是对码元序列进行排序处理，得到字节序列，生成和计算机系统平台相关的编码，这就是真正存储到计算机中的二进制数了。

   为单码元的时候，字符序列和码元序列是一样的，也就是步骤三和步骤四是相同的，物理上的字符编码等于逻辑上的字符编码，但是如果是多码元的情况下，可能码元序列和字符序列是不相等的。

   很多时候`码元序列`和`字节序列`的值是一样的。 

5. 面向计算机更底层，进行进一步的适应性编码处理。 

   这一部分涉及计算机硬件怎么优化处理，我们并不需要了解，但是出于礼貌，还是要照抄一下（一般包括两种）：

   - 一种是把字节序列映射到一套更受限制的值域内，以满足传输环境的限制，例如用于Email传输的Base64编码或者quoted-printable编码(可打印字符引用编码)，都是把8位的字节映射为7位长的数据(Email协议设计为仅能传输7位的ASCII字符)；
   - 另一种是压缩字节序列的值，如LZW或者进程长度编码等无损压缩技术。

## 具体字符集

### ASCII字符集

ASCII(American Standard Code for Information Interchange )，美国信息交换用便准代码。计算机这货是人家老美发明的，所以好多命名都是以老外的习惯命名的。

目前ASCII字符集共收录了128个字符，编号为0-127，咱们上面也介绍了，忘了的小伙伴可以去上面看看。

由于编号的范围较小，所以转化为二进制时只需要一个字节就可以表示出来了，也就是ASCII编码是单码元的。

举一个例子，例如字母`SLL`，因为S对应的ASCII编码为83，L对应的编码为76，所以SLL这个字符串对应的字节序列或码元序列为

```
01010011 01001100 01001100
```

### ISO-8859系列

为什么称之为ISO-8859系列呢，因为ISO-8859共有15个字符级，即1-16（12未定义），其实本质上他们和ASCII字符集差不多，只不过每一个字符集都比ASCII字符集多收录了96个字符，原有的ASCII字符编号是不变的，新增加的字符位于160-255这个编号内，由于还是采用一个字节就可以表示其编号，所以ISO-8859系列字符集还是单码元的，直接把编号映射为二进制数据即可。

我们可能常用的只有ISO-8859-1了，浏览器默认的编码就是这个，这里面除了原有的ASCII编码，还收录了一些西欧常用的字符，他还有一个别名，叫做Latin-1，这个名字熟悉吧，在mysql数据库字符集中见到过吧。

### GB2312字符集

说起GB2312字符集，大家应该都不陌生，这是咱们中国人的字符集，支持汉字编码，也是咱们伟大的中国人民设计的。

1. 收录字符范围 它收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。

   注意，`GB2312字符集`并没有收录`ASCII字符集`中的字符哦。

2. 字符编号 由于`GB2312字符集`收录的字符太多，所以暴力编号不好管理，就提出了一个`分区`的概念。就像下图这样： 

![image_1bqjvij2mipa1oeh12781i1t92d2a.png-43.6kB](https://user-gold-cdn.xitu.io/2019/3/10/1696587146da4fde?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	如上图，每一个黄色的椭圆块可以代表一个`分区`，简称`区`。一共设计了94个`区`(01-94)，每个区可以放94个`字符`(01-94)。 

所以定位某一个字符的方式就是在第几分区的第几位字符。比如汉字`啊`，这个字被放在了第16区的第1位，所以`啊`对应的数字就是`1601`。因为是按第几区的第几位来划分，所以也叫`区位码`，就可以说`啊`字对应的`区位码`是`1601`。 

> 其实所谓的`区`和`位`，本质上和`行`和`列`是一样一样的。 一个分区就代表一行，一位就代表一列。第几区第几位的意思就是第几行第几列。 

哪个`分区`放什么样的字符都是规定好的，有的分区也没有放东西，就空在哪。各个分区都储存了哪些字符： 

- `01-09`区为特殊符号，字符包括特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等 

- `10-15`区没有编码，为了以后新加入字符来扩展。
- `16-55`区为一级汉字，也就是常用的汉字，按拼音排序，共`3755`个。
- `56-87`区为二级汉字，也就是非常用汉字，按部首／笔画排序，共`3008`个。
- `88-94`区没有编码，留着给以后扩展。

如果大家想查看某个汉字的`区位码`或者查看完整区位码的图，可以到这里：[GB2312区位码查询与转换](http://www.mytju.com/classcode/tools/quweima.asp)

3. 编码 在对`GB2312字符集`进行编码前我们需要正视这个问题：`GB2312字符集`并没有收录`ASCII字符集`中的字符，如果一个英文字母出现在文本里该怎么编码成二进制数据。

   我们在说`GB2312编码`的意思其实是表达了这么两重意思：

   - 如果该字符在`ASCII字符集`中，就按照`ASCII编码`的方式进行编码。
   - 如果该字符在`GB2312字符集`中，就按照`GB2312编码`的方式进行编码。

   `解码`就是`编码`的逆过程。 

    有了上边的说明，我们再回来给`GB2312字符集`中的字符进行`编码`的话题。我们最初的想法是： 

   像`ASCII字符集`的编码方式一样，直接把`GB2312`字符集的`编号`，也就是`区位码`来当作`编码`。

   拿我的姓 `王`举个栗子，`王`字在第45区第85位，区位码就是`4585`，转换成二进制就是：

   ```
   10001 11101001
   复制代码
   ```

   如果用两个字节来表示就是：

   ```
   00010001 11101001
   复制代码
   ```

   但是在计算机读这一串二进制数据时，比如它读到了第一个字节`00010001`(十进制是`17`)，它怎么区别这是`王`字的编码一部分，还是`ASCII编码`中的第`17`号字符呢？答案就是没法区分。

   但是我们知道`ASCII编码`只用了一个字节中的`0~127`，其中的`128~255`是没有用到的，所以我们给`编码`后的每个字节都加`128`(二进制是`10000000`)这样就不会出现单个字节小于`128`的情况喽！试试：

   ```
       00010001
   +   10000000
   ____________
       10010001
   ```

   ```
       11101001
   +   10000000
   ____________
       01101001(进位舍去)
   ```

   高字节`00010001`加`128`之后没问题，但是低字节`11101001`加`128`后出了个大问题，他俩的和超过`255`了，所以只能把进位舍去，结果又成了低于`128`的值了。

   显然，这样把各个字节都直接加`128`还是不靠谱的。因为我们不能保证每个字节的值都小于`128`，所以不能保证加完后的和小于或等于`255`。

   为了解决这个问题，我们又提出了另一个方案：

    不直接把`区位码`映射为`编码`，而把区号作为一个字节，把位号作为另一个字节。这样`王`字的区位号`4585`就可以看作`45`和`85`的拼装，然后把`45`和`85`分别转为一个字节：

   ```
   00101101(十进制45)
   01010101(十进制85)
   ```

   拼起来就是：

   ```
   00101101 01010101
   ```

   但是这样做仍然有和`ASCII编码`分不清的问题。所以需要把每个字节都加上`127`: 45 + 127 = 172(二进制`10101100`)；    85 + 127 = 212(二进制`11010100`)；

   所以拼接而成的结果就是：

   ```
   10101100 11010100
   ```

   这种拼装就没有和大于`255`的情况么？别忘了我们的两个字节是怎么生成的，每个字节的值其实是区号或者位号。我们前边说过我们一共有94个区，每个区最多有94个字符，所以字节最大值就是94，`94`和`128`相加肯定不会大于`255`呀～

   你以为上边就是终极编码版本？才不是呢。

   因为区码范围在`1-94`之间，位码也在`1-94`之间。所以理论上只要给区码，位码加在`127～161`区间的数就可以避免与`ASCII编码`冲突了。但是最后决定给`区码`和`位码`都加`160`。

   ```
   为什么是160呢？
   
   我都说了在`127～161`的数都可以，不信你试试。
   ```

   最后结论也就是`GB2312编码`过程就是把`区位码`的区码和位码都加`160`，然后拼成两个字节。

   比如`王`字的区位号`4585`，就把`45`和`85`都加160:

   ```
   45 + 160 = 205 (二进制`11001101`)
   85 + 160 = 245 (二进制`11110101`)
   ```

   所以最后拼成最后的编码就是：

   ```
   11001101 11110101
   ```

   转成十六进制就长这样：

   ```
   CDF5
   ```

    最后总结一下就是：所谓`GB2312编码`包含两个部分：

   - 如果该字符在`ASCII字符集`中，就按照`ASCII编码`的方式进行编码。
   - 如果该字符在`GB2312字符集`中，就按照`GB2312编码`的方式进行编码。

    对于`GB2312中的字符进行编码是这个过程`：

   ```
   把`区位码`的区码和位码都加`160`，然后拼成两个字节
   复制代码
   ```

   `解码`过程就是上边`编码`的逆过程。

   再举个完整点的栗子，比如我们有这样一段文本：

   ```
   我爱u
   复制代码
   ```

   然后用`GB2312编码`来编码这段文本的过程就是：

   - `我`对应的区位码是`4650`，编码后的十六进制是`CED2`，也就是二进制：`1100111011010010`。

   - `爱`对应的区位码是`1614`，编码后的十六进制是`B0AE`，也就是二进制：`1011000010101110`。

   - `u`是`ASCII字符集`字符，编码后是`75`，二进制就是：`01001011`。

   - 拼合起来的结果就是：

     ```
     1100111011010010101100001010111001001011
     复制代码
     ```

     这串二进制位的十六进制表示就是：`CED2B0AE4B`。

   然后计算机在`解码`这段二进制数据时的过程就是：

   - 读一个字节`CE`，发现它大于`127`，所以这是一个两个字节的字符，所以连续读了两个字节`CED2`，在编码表里查到这是汉字`我`。
   - 接着再读一个字节`B0`，发现它大于`127`，所以连续读了两个字节`B0AE`，在编码表里查到这是汉字`爱`。
   - 接着再读一个字节`4B`，发现它小于`127`，所以在ASCII码表里查到这是英文子母`u`。

   栗子讲完了。由于`GB2312`字符集收录的字符太多，所以只展示一点，大家看明白就好：

   ### GBK与GB18030字符集

   有了`GB2312`大家很高兴，但是没过多久大家就发现中国字太多了，连中国前总理朱镕基的"镕"字都没有收录。

   `GBK`字符集就是在`GB2312`的基础上，对它收录的字符做了一个扩充，共收录 `21886` 个汉字和图形符号。

   `GB18030`字符集在`GBK`的基础上又做了个扩充，收录汉字`70244`个。

   它们的和`GB2312`属于同祖同宗，就不介绍它们的字符编码模型了～

   ### Big5字符集

   又称大五码或五大码，宏碁(Acer)、神通(MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。是台湾同学发明的。具体的字符编码模型我们也不需要了解哈～ 

   ### unicode字符集

   世界上像中国这样定义`字符集`的国家有很多，所以各国人民商量了一下，发布了一个文件，叫`The Unicode Standard`，这个文件废除了`ASCII字符集`以外的所有字符集，定义了一个大家都通用的字符集，就是`Unicode字符集`。 

   1. 收录字符范围 收录地球上能想到的所有字符，而且还在不断扩充。
   2. 字符编号 因为收录的字符太多，而且还可能不断地添加新字符，暴力编号显然不便于管理。所以`Unicode字符集`设计者们提出了一个`平面`(英文名叫`Plane`)的概念。

   ![image_1bqrccs35sqp8ki1pjn1o8h1o929.png-29.2kB](https://user-gold-cdn.xitu.io/2019/3/10/1696587146264cf9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   一共设计了17(编号从`0`~`16`)个平面，每个平面可以包含65536(`0~65535`)个编号。各个平面的编号范围见下图(十六进制表示)： 

   ![image_1bqrd0pd41um41c0du4jccphnam.png-110.8kB](https://user-gold-cdn.xitu.io/2019/3/10/1696587175041049?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   在这设计的17个平面中，其中第0个平面是包含了当前世界上最常用的一些字符。所以这第0个平面也叫做`BMP`(英文`Basic Multilingual Plane`的缩写)，翻译过来就是`基本多语言平面`。它是我们最经常用到的。 其他的平面叫做辅助平面（简称 SMP ） 。

   我们在说某个`unicode字符集`中的字符的编号的时候通常会用下边的这种方式：

   ```
   U+十六进制编号
   ```

   举个栗子，`王`字的十六进制编号是`738B`，所以我们就写成：

   ```
   U+738B
   ```

   这个`U+738B`就代表一个`unicode字符`的编号。

   另外，`unicode字符集`的编号兼容了`ASCII字符集`的编号和`ISO 8859-1字符集`的编号。`unicode字符集`中的`U+0000~U+007F`(即十进制的0~127)与`ASCII字符集`是一致的，`U+0000~U+00FF`(即十进制的0~255)与`ISO 8859-1字符集`(Latin-1字符集)也是一致的。比如大写字母`A`的编号都是`65`，左大括号`{`的编号都是`123`。

   unicode占据两个码元，也就是必须使用两个字节的内容才能表示，因为两个字节只能表示出65536个，也就是只能表示出基本多语言平面中的字符，因此，就出现了各种衍生编码。

   ### UTF8编码

   这里面注意，UTF8不是字符集，他的字符集是unicode，他只不过是unicode的另一种编码方案。

   这种编码方案的`码元`采用一个字节。但是一个字节最多只能表示256个字符，所以有的字符需要多个字节来表示，但这就产生了一个问题：计算机如何区分哪个字符是用一个`码元`(此处是1字节)表示，哪个字符使用多个`码元`表示的？

   `UTF-8编码`是用首字节的开头几位来辨别是用几个字节编码的：

   - 如果首字节以0开头，肯定是单字节编码(单个码元)；

   - 如果首字节以110开头，肯定是双字节编码(2个码元)；

   - 如果首字节以1110开头，肯定是三字节编码(3个码元)。

     ... 依次类推

   另外，如果某个字符是由多个字节编码的，那除了首字节外，其余字节都需要用10开头，以区别单字解释编码和多字节编码的首字节。

   上边字节的首字母0、110、1110以及10相当于UTF-8编码中各个字节的前缀，因此称之为`前缀码`。其中，前缀码110、1110及10中的0，是前缀码中的`终结标志`。这些`前缀码`只是用来标记的，不用来代表真实的字符编号。所以其实真正有效的用来代表`unicode字符`真实的字符编号的位数是：

   - 单字节中有效编码位数是7位(除去首字节前缀0)

   - 双字节中有效编码位数是11位(除去首字节前缀110和第二字节的前缀10)

   - 三字节中有效编码位数是16位(除去首字节前缀1110和第二、三字节的前缀10)

     ... 依次类推

   用表格表示一下就是这样的：

   | 描述       | 有效编码位数 | 高位字节 | 低位字节 | 低位字节 | 低位字节 | 低位字节 |
   | ---------- | ------------ | -------- | -------- | -------- | -------- | -------- |
   | 单字节编码 | 7            | 0xxxxxxx |          |          |          |          |
   | 双字节编码 | 11           | 110xxxxx | 10xxxxxx |          |          |          |
   | 3字节编码  | 16           | 1110xxxx | 10xxxxxx | 10xxxxxx |          |          |
   | 4字节编码  | 21           | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |          |


   所以我们对某个`unicode字符`进行编码的时候，就可以这么办：

   - 查看该`unicode字符`对应的编号位数，查看它应该采用几个字节来进行编码。
   - 选取好用几个字节来进行编码后，采用上表的模版，保持前缀不变，把字符编号填到非前缀位上，高位用0补足即可。

   举个栗子，比如字符`u`，它的编码过程是：

   - `u`的`unicode编号`是`117`(二进制`1110101`)，占7个位，所以用1个字节编码就够了。
   - 采用1字节编码模板`0xxxxxxx`，把里头的`xxxxxx`替换成`1110101`就好了。

   所以`u`字符的`UTF-8`的编码结果就是：

   ```
   01110101
   ```

   再比如汉字`啊`，它的编码过程是：

   - `啊`的`unicode编号是`21834`(二进制`101010101001010`)，占15个位，需要用2个字节编码。
   - 所以采用3字节编码模板`1110xxxx 10xxxxxx 10xxxxxx`，把二进制数据填进去，高位补0。

   所以`啊`字符的`UTF-8`的编码结果就是(字节之间的空格是方便我们阅读，实际是没有的，下边就不强调这个了)：

   ```
   11100101 10010101 10001010
   ```

   用友好一点的十六进制表示就是：

   ```
   E5958A
   ```

   作用：utf8编码主要就是弥补了unicode的不足，因为unicode编码是固定长度的，只能用两个字节表示，像ASCII这样的字符放在里面就会浪费空间，而U8是可变长度的。

   ### UTF16编码

   这种编码方案的`码元`采用2个字节。

   我们知道`unicode字符集`基本多语言平面(也就是第0平面)，编号范围是:0 ~ 65535(十六进制：`0xFFFF`)。其余的16个平面(1～16平面)编号范围为：65536~1114111(十六进制：`0x10000~0x10FFFF`)。

   但是2个字节最多只能表示65536个字符，所以1个两字节的`码元`最多只能直接表示基本多语言平面的编号，所以在表示其余的16个平面的字符时需要用多个`码元`。所以`UTF-16编码方案`和`UTF-8编码方案`一样，也会有这个问题：

   ```
   计算机如何区分哪个字符是用一个`码元`(此处是2字节)表示，哪个字符使用多个`码元`表示的？
   ```

   `UTF-16`提出了一个`代理区`的概念来解决这个问题。

   他们规定基本多语言平面的十六进制U+D800 到 U+DFFF这个区间的编号为`代理区`，这个区间的编号并不对应字符。

   有了`代理区`的概念之后，`UTF-16`提出的完整解决方案就是：

   1. 对于基本多语言平面(也就是第0平面)中不属于`代理区`编码的字符，使用一个码元(2字节)，编号直接映射为字符编码。

   2. 对于第1～16平面，采用两个码元来进行编码，具体编码原理见下文。

      - 第一个码元的取值范围是`0xD800~0xDBFF`(二进制为`11011000 00000000` ~ `11011011 11111111`，十进制为`55296 ~ 56319`)，

        第二个码元的取值范围为`0xDC00~0xDFFF`(二进制为`11011100 00000000` ~ `11011111 11111111`，十进制为`56320 ~ 57343`)。

      - 根据上一步确定的码元的取之范围，可以得出它的二进制表现形式： `110110pp ppxxxxxx 110111xx xxxxxxxx` 可以看到，它的有效编码位数只有20位，其中4位`pppp`代表该编码所在平面(1~16)，16位`xxxxxxxxxxxxxxxx`代表在该平面的位置。

      然后这有效编码位数的20位一共可以表示2的20次方，也就是1048576个编码，正好把16个平面的字符都表示完。

   下边看下怎么对字符`u`进行`UTF-16`编码：

   1. `u`字符的`unicode编号`是`117`(二进制`1110101`)，这个编号小于`65536`，在基本多语言平面中，所以采用直接将编号转为编码的方式进行编码，但是`码元`是两字节的，所以高位补0就行。

      字符`u`的`UTF-16`的编码结果就是：

      ```
      00000000 01110101
      ```

      注意：`UTF-16`编码最少采用2个字节，导致了像英文字母这样在`0~127`编号的字符也得用2个字节编码。而`UTF-8`只需要1个字节来编码`0~127`编号的字符。所以`UTF-16`在编码`0~127`编号的字符的时候会比`UTF-8`浪费。

   再看`啊`字的栗子：

   1. `啊`的unicode编号是`21834`(二进制`101010101001010`)，这个编号小于`65536`，在基本多语言平面中，所以采用直接将编号转为编码的方式进行编码，但是`码元`是两字节的，所以高位补0就行。

      字符`啊`的`UTF-16`的编码结果就是：

      ```
      01010101 01001010
      ```

   我费了老大劲找了个生僻汉字`𨢻`，看他的编码过程：

   1. `𨢻`的unicode编号是`166075`(二进制`101000100010111011`)，这个编号不小于`65536`，在第2平面中，所以到第二步来处理。
   2. 根据`110110pp ppxxxxxx 110111xx xxxxxxxx`这个式子，因为在第2平面中，所以`pppp`对应的二进制就是`0010`，这个字在第2平面的第`60514`(二进制`1110110001100010`)位，所以`xxxxxxxxxxxxxxxx`就可以被替换成`1110110001100010`。

   所以字符`𨢻`的`UTF-16`的编码结果就是：

   ```
   11011100 10111011 11011000 01100010
   ```

   ### UTF32

   这种编码方案的`码元`采用4个字节。

   因为整个`unicode字符集`目前编码范围是17个平面，每平面65536个编号，所以一共是`1114112`个数。4个字节就可以表示`4294967296`个数，所以使用一个码元(4字节)就可以表示所有的编号喽。

   比如`u`字符，`u`字符的`unicode编号`是`117`(二进制`1110101`)，所以就直接被编号为：

   ```
   00000000 00000000 00000000 01110101
   ```

   再看`𨢻`字符，它的`unicode编号是`166075`(二进制`101000100010111011`)，所以就直接被编号为：

   ```
   00000000 00000001 01000100 010111011
   ```

   ### 字节序

    物理编码 在谈这个之前需要介绍一下`字节序`的概念。

   `字节序`(`Byte-Order`)就是指存放多字节数据的字节（byte）的顺序。

   什么叫`多字节数据`？`多字节数据`就是计算机在读取二进制数据时一次要读好几个字节。比如我们之前介绍java的数据类型中，`short`就是一次要读四个字节，`int`就是一次要读四个字节，`long`就是一次要读8个字节。`short`、`int`和`long`类型的数据就是`多字节数据`。但是比如`byte`类型的数据就不是`多字节数据`。

   如果数据都是单字节的，那怎么存储无所谓了。字节序是硬件层面的东西，对于软件来说通常是透明的，但是我们现在就是要说明白怎么储存，没办法，硬着头皮看吧～。

   比方说我们在java代码里定义了一个`int`类型的十六进制值：

   ```
   int i = 0xaabbccdd; //二进制数据就是 10101010 10111011 11001100 11011101
   复制代码
   ```

   那么左边的`0xaa`(`10101010`)就是高字节，当然这个高低是相对的，比如`0xbb`和`0xcc`相比是高字节，`0xcc`和`0xdd`相比也是高字节，`0xbb`和`0xdd`相比是高字节。

   现在我们可以根据变量`i`这货在内存里到底是怎么放的来定义`大端序`(`Big-Endian`)和`小端序`(`Little-Endian`)喽。

   `大端序`(`Big-Endian`)就是高字节存放在地址的低端 低字节存放在地址高端。就是这样：

   ![image_1bqshe0rj20m16ep1ef41a5pi5113.png-17.1kB](https://user-gold-cdn.xitu.io/2019/3/10/169658717bc9da72?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   ```
   0xaabbccdd
   ```

   `小端序`(`Little-Endian`)就是高字节存放在地址的高端 低字节存放在地址低端。就是这样：

   ![image_1bqshkdma15l2m4g15qhgpa1i0q1t.png-16.6kB](https://user-gold-cdn.xitu.io/2019/3/10/169658717df52b9d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   ```
   0xaabbccdd
   ```

   也就是说，如果`i`变量在内存里的顺序是`0xaabbccdd`的话，这种书写方式就是`大端序`。

   如果`i`变量在内存里的顺序是`0xddbbccaa`的话，这种书写方式就是`小端序`。

   如果怕记不住的话，可以这么理解：

   ```
   `大端序`就是按照人类理解的顺序进行存储的，从左至右，从高字节到低字节。
   
   `小端序`就是按照反人类理解的顺序进行存储的，从左至右，从低字节到高字节。
   ```

   一些操作系统比如Windows、FreeBsd、Linux是采用Little-Endian的；一些操作系统比如Mac OS是采用Big-Endian的。

   有了`大端序`、`小端序`的概念之后，我们再看`码元`大于一个字节的编码方式的具体不同：

   ###### UTF-16Be编码

   就是`UTF-16`的逻辑编码。就是说高字节在左边，低字节在右边。

   比如`啊`字的`UTF-16Be编码`就是：

   ```
   01010101 01001010
   ```

   转成十六进制就是：

   ```
   554A
   ```

   ###### UTF-16Le编码

   就是`UTF-16`的逻辑编码采用`小端序`的字节序列。就是说高字节在右边，低字节在左边。

   比如`啊`字的`UTF-16Le编码`就是：

   ```
   01001010 01010101
   ```

   转成十六进制就是：

   ```
   4A55
   ```

   ###### UTF-32Be编码和UTF-32Le编码

   与上边的`UTF-16Be编码`和`UTF-16Le`编码是一样的意思。

   ###### 文件头加表明字节序的字符

   因为有`大端序`和`小端序`之分，所以在采用`UTF-16`和`UTF-32`编码时需要在文本文件开始指定使用`大端序`还是`小端序`。指定方式如下：

   1. 如果是`大端序`编码，需要在文件开始加一个字符`U+FEFF`。当然，`UTF-16编码`会把这个字符编码成2个字节，`UTF-32编码`会编码4个字节。
   2. 如果是`小端序`编码需要在文件开始加一个字符`U+FFFE`。当然，`UTF-16编码`会把这个字符编码成2个字节，`UTF-32编码`会编码4个字节。

   注意，有的windows程序，比如记事本啥的，在采用`UTF-8`编码的时候，会在文件开头加上一个`U+FEFF`字符，编码值是`0xEFBBBF`(十六进制)。但是`UTF-8`是没有字节序一说的，windows没事找事添加的，大家知道就行了，如果用记事本敲代码导致了出错，就往编码这想想。

​    

​    

​    

​    

​    

​    

​    

 