# Java虚拟机架构

## 0. 前言

刚学java的第一课可能就会听说，java是一个`平台无关性`的语言，即一次编译可在各平台运行，之所能达到这种效果，就是因为有`java虚拟机-JVM`的存在。java编译器将java的源文件`编译`成class字节码文件，然后每次运行的时候就会实用类加载器将class`加载到执行引擎中`执行。

但是很多人并不知道JVM到底是怎么一回事，其实JVM就是一套虚拟的机器，学过操作系统的小伙伴可能会知道，虚拟机是一个非常火热的技术，其实JVM和VMWare所实现的原理是一样的，只不过`JVM是单进程多线程`的，其中`每个线程`又对应`操作系统的一个进程`。

## 1.  JVM架构

​                                     ![img](https://img-blog.csdn.net/20160514120258073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这就是JVM的架构图，这张图是我借鉴别人的。可以看出 整个JVM的核心包括 `Class Loader + Execution Engine + Runtime Data Area`，接下来就详细说一下各个结构。

## 3. 类加载器

类加载器就是负责把Java Compiler编译好的class文件加载到执行引擎和运行时数据区中，本身并不具备执行java代码的功能，只是起到了一个传输的作用，是JVM的入口。

## 4. 执行引擎

主要作用就是执行类加载器加载过来的class代码

## 5. 运行时数据区

这其实是一个挺重要的概念，运行时数据区分了好几部分，其中就有大家比较熟悉的堆和栈，但这是笼统的，接下来给大家好好介绍一下，先来看张图

​                   ![img](https://img-blog.csdn.net/20160819150110871)    

这张图也是我借鉴过来的，因为我画的图实在是太丑了，把运行时数据区一共分了5部分

+ PC寄存器
+ JVM栈
+ 本地方法区
+ 堆
+ 方法区

**JDK1.6之后，原在方法区运行时常量池移到了堆中**

### 5.1 PC寄存器

PC寄存器主要用于存储当前线程执行的数据，当线程被切换时，能保证在次回到此线程时，是接着上次正在执行的位置执行。

当使用native方法时，此寄存器为空

+ native方法使用时机是想调用其他编程语言时使用的修饰字段
+ native方法主要就是调用动态链接库（DLL， Dynamic Link Library ， c语言所用，可以分模块化构建项目）

PC寄存器区域没有被限制大小，所以见不到OutOfMemoryError异常

### 5.2 JVM栈

JVM栈中存储的是一些对象的指针或者一些栈帧以及一些局部变量，其中大家熟知的就是对象的指针。

>  每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为"栈帧"。JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。  

在java中的方法运行时，每个方法都会变成一个栈帧，其中栈帧又包含

+ 局部变量表（当前方法的局部变量表）
+ 操作数栈（执行运算时需要的）
+ 帧数据（当前方法的信息）

每个方法涉及的局部变量表和操作数栈的大小取决于每个具体的方法，但是大小在编译后便已确定，而且已经包含在class文件中。当JVM执行一个方法时，它会检查class中的数据，以便确定一个方法执行时在局部变量表和操作数栈中所需存储的word size。然后，JVM会为当前方法创建一个size相对应的栈帧，然后把它push到栈顶。

执行方法，会把当前这个栈帧push到栈中，称为当前帧，当这个方法结束时，会将这个栈帧pop掉，因为JVM栈的大小是有限制的，可以扩充，但是当因为运行的方法过多导致扩充到一定地步没有办法继续扩充时，会抛出异常，OutOfMemoryError，当JVM到达一定深度之后，会抛出StackOverflowError，这种场景多半是在无限递归下才能看到。

**栈的优点:**

+  栈帧内存数据共享：栈帧之间数据不能共享，但是同一个栈帧内的数据是可以共享的，这样设计是为了减小内存消耗，例如：int a = 1, int b= 1时，前面定义了a=1，a和1都在栈内存内，如果再定义一个b=1，此时将b放入栈内存，然后查找栈内存中是否有1，如果有则b指向1。如果再给b赋值2，则在栈内存中查找是否有2，如果没有就在栈内存中放一个2，然后b指向2。也就是如果常量在栈内存中，就将变量指向该常量，如果没有就在该栈内存增加一个该常量，并将变量指向该常量
+ 存取速度比堆要快，仅次于寄存器。速度快之一是栈在编译器就申请好了内存空间，所以在运行时不需要申请内存大小，节约了时间，其二是栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。其三是访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。

**栈的缺点：**

+ 存在栈的数据大小和生存期必须是确定的，缺乏灵活性。当栈在运行执行程序时，发现栈内存不够，不会动态的去申请内存，以至于导致程序报错，所以灵活性较差。 

###  5.3 本地方法栈

本地方法栈和JVM栈是类似的，只不过JVM栈是为java代码使用的，而本地方法栈是为native方法使用的。

同样也会产生OutOfMemoryError和StackOutOverFlowError错误

### 5.4 堆

+ 在java中，堆是最大的一块内存空间，他大约是栈的2倍，我们所说的对内存进行管理其实就是在管理这一部分。
+ 堆在物理磁盘上不一定是连续的，但是在逻辑上是连续的
+ 堆内存不够时，会动态的扩充，但是当扩充的一定大小时，会抛出OutOfMemoryError异常
+ 堆是线程之间共享的
+ 所有的实例对象几乎都存储在堆中

### 5.5 方法区

方法区主要用于存放一些类的信息、静态变量、编译后的java代码，我们通过反射获取的一些信息就是从这里面获取的，在分代收集算法中，这一部分对应永久代。这里面还包含有运行时常量池，这里面主要放一些静态常量和编译时就已知的常量，类似于一个大的缓冲区。但是并不是常量池只有在编译的时候才可以加入，还有一些事可以在程序运行时加入，例如：String的intern方法。同样，当内存不够时，会抛出OutOfMemoryError异常。

**注意JDK1.6以后将常量池转移到了堆中**

## 6. 堆和栈的区别

+ 各司其职（堆中只存放那些被new出来的实体。而占中主要存放一些变量的引用、局部变量等等）
+ 空间大小（堆的空间大约是栈的2倍）
+ 共享性      (堆是被所有线程共享的，而栈是线程。私有的)
+ 所抛出来的异常  (堆中会抛出来OutOfMemoryError和StackOverflowError异常，而堆中只能抛出来OutOfMemoryError异常)



